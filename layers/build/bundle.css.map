{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "..\\..\\App.svelte",
    "..\\..\\Cell.svelte"
  ],
  "sourcesContent": [
    "<script>\r\n  import Cell from \"./Cell.svelte\";\r\n  import { width, height, cellCount, regenerate } from \"./cellsStore.js\";\r\n  $: rows = Array($height)\r\n    .fill(null)\r\n    .map((_, y) =>\r\n      Array($width)\r\n        .fill(null)\r\n        .map((_, x) => x + y * $width)\r\n    );\r\n\r\n  function createSections(\r\n    sectionsWide,\r\n    defaultSectionWidth,\r\n    finalSectionWidth,\r\n    sectionsTall,\r\n    defaultSectionHeight,\r\n    finalSectionHeight,\r\n    boardWidth\r\n  ) {\r\n    const sections = [];\r\n    for (let sectionY = 0; sectionY < sectionsTall; sectionY++) {\r\n      for (let sectionX = 0; sectionX < sectionsWide; sectionX++) {\r\n        const height =\r\n          sectionY === sectionsTall - 1\r\n            ? finalSectionHeight\r\n            : defaultSectionHeight;\r\n        const width =\r\n          sectionX === sectionsWide - 1\r\n            ? finalSectionWidth\r\n            : defaultSectionWidth;\r\n\r\n        const firstIndex =\r\n          sectionY * defaultSectionHeight * boardWidth +\r\n          sectionX * defaultSectionWidth;\r\n        const indices = [];\r\n        for (let y = 0; y < height; y++) {\r\n          for (let x = 0; x < width; x++) {\r\n            const offset = x + y * boardWidth;\r\n            indices.push(firstIndex + offset);\r\n          }\r\n        }\r\n        sections.push({\r\n          x: sectionX,\r\n          y: sectionY,\r\n          width,\r\n          height,\r\n          indices\r\n        });\r\n      }\r\n    }\r\n    return sections;\r\n  }\r\n\r\n  $: cellsPerSectionTarget = Math.max(20, $cellCount / 100);\r\n  $: sectionSize = Math.round(Math.sqrt(cellsPerSectionTarget));\r\n\r\n  $: sectionsWide = Math.ceil($width / sectionSize);\r\n  $: sectionsTall = Math.ceil($height / sectionSize);\r\n  $: finalSectionWidth = $width - (sectionsWide - 1) * sectionSize;\r\n  $: finalSectionHeight = $height - (sectionsTall - 1) * sectionSize;\r\n\r\n  $: sections = createSections(\r\n    sectionsWide,\r\n    sectionSize,\r\n    finalSectionWidth,\r\n    sectionsTall,\r\n    sectionSize,\r\n    finalSectionHeight,\r\n    $width\r\n  );\r\n</script>\r\n\r\n<style>\r\n  .sectionGrid {\r\n    display: grid;\r\n    grid-gap: 0px;\r\n  }\r\n\r\n  .boardSection {\r\n    display: grid;\r\n    grid-gap: 0px;\r\n    -webkit-backface-visibility: hidden;\r\n    backface-visibility: hidden\r\n  }\r\n</style>\r\n\r\n<main>\r\n  <div\r\n    class=\"sectionGrid\"\r\n    style=\"grid-template-columns: repeat({sectionsWide}, {sectionSize * 8}px);\r\n    grid-template-rows: repeat({sectionsTall}, {sectionSize * 8}px)\">\r\n    {#each sections as section}\r\n      <div\r\n        class=\"boardSection\"\r\n        style=\"grid-template-columns: repeat({section.width}, 8px);\r\n        grid-template-rows: repeat({section.height}, 8px)\">\r\n        {#each section.indices as idx}\r\n          <Cell index={idx} />\r\n        {/each}\r\n      </div>\r\n    {/each}\r\n  </div>\r\n</main>\r\n",
    "<script>\r\n  import { cellStores, surroundingStores, width } from \"./cellsStore\";\r\n\r\n  export let index;\r\n  $: me = cellStores[index];\r\n  $: surroundings = surroundingStores[index];\r\n\r\n  $: isMine = $me.isMine;\r\n  $: stateKnown = $me.stateKnown;\r\n  $: createsConstraint = stateKnown && !isMine;\r\n\r\n  $: unknownCellsCount = $surroundings.filter(cell => !cell.stateKnown).length;\r\n  $: adjacentMinesCount = $surroundings.filter(cell => cell.isMine).length;\r\n  $: knownMinesCount = $surroundings.filter(\r\n    cell => cell.isMine && cell.stateKnown\r\n  ).length;\r\n  $: remainingMinesCount = adjacentMinesCount - knownMinesCount;\r\n\r\n  $: clearable = createsConstraint && adjacentMinesCount === knownMinesCount;\r\n  $: flaggable = createsConstraint && remainingMinesCount === unknownCellsCount;\r\n\r\n  $: if (clearable) setTimeout(() => surroundings.reveal(), 0);\r\n  $: if (flaggable) setTimeout(() => surroundings.reveal(), 0);\r\n\r\n  let textColor;\r\n  $: if (!stateKnown) {\r\n    textColor = \"transparent\";\r\n  } else if (isMine) {\r\n    textColor = \"white\";\r\n  } else {\r\n    textColor = [\r\n      \"transparent\",\r\n      \"blue\",\r\n      \"green\",\r\n      \"red\",\r\n      \"purple\",\r\n      \"maroon\",\r\n      \"#0aa\",\r\n      \"black\",\r\n      \"#444\"\r\n    ][adjacentMinesCount];\r\n  }\r\n\r\n  $: x = Math.floor(index / $width);\r\n  $: y = index % $width;\r\n  $: light = (x + y) % 2 === 0;\r\n  function getBackgroundColor(stateKnown, isMine, light) {\r\n    if (stateKnown && isMine) return \"#f55\";\r\n    if (stateKnown && !isMine && light) return \"#fff\";\r\n    if (stateKnown && !isMine && !light) return \"#ddd\";\r\n    if (!stateKnown && light) return \"#aaa\";\r\n    if (!stateKnown && !light) return \"#999\";\r\n  }\r\n  $: backgroundColor = getBackgroundColor(stateKnown, isMine, light);\r\n\r\n  $: cellText = isMine ? \"X\" : adjacentMinesCount;\r\n</script>\r\n\r\n<style>\r\n  .cell {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    font-size: 5pt;\r\n    font-weight: 700;\r\n    height: 8px;\r\n    width: 8px;\r\n  }\r\n</style>\r\n\r\n<div\r\n  class=\"cell\"\r\n  style=\"color: {textColor}; background-color: {backgroundColor}\">\r\n  {cellText}\r\n</div>\r\n"
  ],
  "names": [],
  "mappings": "AA0EE,YAAY,eAAC,CAAC,AACZ,OAAO,CAAE,IAAI,CACb,QAAQ,CAAE,GAAG,AACf,CAAC,AAED,aAAa,eAAC,CAAC,AACb,OAAO,CAAE,IAAI,CACb,QAAQ,CAAE,GAAG,CACb,2BAA2B,CAAE,MAAM,CACnC,mBAAmB,CAAE,MAAM;EAC7B,CAAC;ACzBD,KAAK,cAAC,CAAC,AACL,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,MAAM,CACvB,SAAS,CAAE,GAAG,CACd,WAAW,CAAE,GAAG,CAChB,MAAM,CAAE,GAAG,CACX,KAAK,CAAE,GAAG,AACZ,CAAC"
}